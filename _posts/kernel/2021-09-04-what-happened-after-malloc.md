---
title: What happened after malloc
date: 2021-09-03 0:33:50
tags: linux, kernel
layout: post
---





我在一次面试中被问到这个问题。他们想知道的是，**当用户调用malloc()分配内存时，发生了什么？调用了哪些函数？操作系统是如何响应的？**



现在试着解答这个问题：

当用户空间应用程序调用malloc()时，该调用不会在内核中实现。相反，它是一个库调用(实现了glibc或类似的)。简单来说，glibc中的malloc实现要么从brk()/sbrk()系统调用中获取内存，要么通过mmap()获取匿名内存。这给glibc提供了一个大的连续(关于虚拟内存地址)内存块，malloc实现进一步将其切片并分割成更小的块并分发给应用程序。

注意，目前还不关心物理内存——当通过brk()/sbrk()或mmap()改变进程数据段时，以及当内存被引用(通过对内存的读或写)时，物理内存由内核虚拟内存系统处理。

sbrk 系统调用移动数据段的“边界”。这意味着它移动了一个区域的边界，在这个区域中程序可以读/写数据(允许它增长或收缩，尽管malloc方法没有真正将内存段返回给内核)。除此之外，还有mmap，它用于将文件映射到内存中，也用于分配内存(如果需要分配共享内存，则使用mmap)。



总结:

- Malloc()将搜索它的内存池，以查看是否有一块未使用的内存满足分配需求。
- 如果失败，malloc()将尝试扩展进程数据段(通过sbrk()/brk()或在某些情况下mmap())，Sbrk()最终在内核中结束（实际上使用由buddy分配器分配的内存）。
- 内核中的brk()/sbrk()调用会调整进程的struct mm_struct中的一些偏移量，因此进程数据段会变大。首先，没有物理内存映射到扩展数据段所提供的额外虚拟地址。
- 未映射内存第一次被访问(很可能是malloc实现的读/写操作)时，错误处理程序将进入并捕获到内核，内核将在那里为未映射内存分配物理内存。

请注意：malloc不直接处理物理内存。在面试的时候我想多了，想着怎么跟后面的物理内存分配连起来，实际上那是另一个问题了。