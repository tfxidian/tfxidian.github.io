---
title: Seccomp tutorial
date: 2021-08-14 16:15:50
tags: Seccomp
layout: post
---


## Seccomp
Seccomp是一种安全机制，通过禁止在执行过程中进行的系统调用来帮助程序员将自己的程序沙箱化.
我们将看到3种使用seccomp的方法:
- 严格模式:原始模式，不是很灵活
- 过滤模式:一个更好的版本，但仍然不是很方便
- libseccomp:一个高级API，以非常简单的方式使用seccomp

严格模式，限制程序只能使用四个syscall:

prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);

自定义模式，可以通过 filter 进行限制
prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog);
prog 是一个结构体，其中可以配置 filter，后文介绍。

## 严格模式
Seccomp严格模式是第一个被添加到linux内核的模式。它只允许4个系统调用:read()， write()， exit()和sigreturn()。所有其他系统调用都将导致SIGKILL。
先看在使用seccomp之前的情况，例如有一个程序：

```

#include<stdlib.h>
#include<stdio.h>
#include<unistd.h>

int main()
{
	printf("this is the beginning.\n");
	fork();
	printf("see you again.\n");
	return 0;
}

```

使用gcc test.c -o test生成test，然后运行：
```
this is the beginning.
see you again.
see you again.
```
由结果可见，fork可以正常使用。

然后试一下严格模式下的seccomp,使用方式很简单：
- 在头文件中加入sys/prctl.h和linux/seccomp.h
- 在文件中加入`prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);`

```
#include<stdlib.h>
#include<stdio.h>
#include<unistd.h>
#include<sys/prctl.h>
#include<linux/seccomp.h>

int main()
{
	printf("this is the beginning.\n");
	prctl(PR_SET_SECCOMP,SECCOMP_MODE_STRICT);
	fork();
	printf("see you again.\n");
	return 0;
}

```

同样编译运行，执行发现下面输出：
```
this is the beginning.
Killed
```

## 过滤模式

滤波是基于BPF的。它是一个使用非常简单的指令集的虚拟机。最初用于过滤网络流量，现在它支持seccomp的内核系统调用过滤。
指令包含在这样的结构中：
```
struct sock_filter {	/* Filter block */
	__u16	code;	/* Actual filter code */
	__u8	jt;	/* Jump true */
	__u8	jf;	/* Jump false */
	__u32	k;	/* Generic multiuse field */
};
```

*每个 filter 对应一条规则*
第一个字段是操作码，写成16位数字。在操作码是跳转条件的情况下，下两个字段从当前指令位置偏移8位。最后一个字段是通用字段，可以用于不同的操作码。

prog这个结构体用来存放 filter 的数量以及 filter指针

```struct sock_fprog {
   unsigned short      len;    /* Number of BPF instructions */
   struct sock_filter *filter; /* Pointer to array of
                                  BPF instructions */
};```


一个完整的简单例子：

```
#include <stdio.h>
#include <sys/prctl.h>
#include <linux/seccomp.h>
#include <linux/filter.h>
 
int main(){
        struct sock_filter filter[] = {                 //规则更改在此处完成
                BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL),   //规则只有一条，即禁止所有系统调用
};
        struct sock_fprog prog = {                                    //这是固定写法
                .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),//规则条数
                .filter = filter,                                         //规则entrys
};
        prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);             //必要的，设置NO_NEW_PRIVS
        prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog);//过滤模式，重点就是第三个参数，过滤规则
        printf("test");
}

```
上面的例子把所有的系统调用都给禁掉了。




## libseccomp 
程序劫持程序流后通过execve的syscall来getshell。通过seccomp我们可以在程序中禁用掉某些syscall，这就就算劫持了程序流也只能调用部分的syscall了.

原程序如下：
```
#include<stdio.h>
#include<unistd.h>
#include<seccomp.h>
#include<sys/syscall.h>

int main()
{
  printf("this is the beginning.\n");

  char * filename = "/bin/sh";
  char * argv[] = { "/bin/sh", NULL };
  char * envp[] = { NULL }; 
  syscall(59, filename, argv, envp);

  return 0;
}

```

利用libseccomp过滤execv系统调用

```
#include<stdio.h>
#include<unistd.h>
#include<seccomp.h>
#include<sys/syscall.h>

int main()
{
  printf("this is the beginning.\n");
  scmp_filter_ctx ctx;
  ctx = seccomp_init(SCMP_ACT_ALLOW);
  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);
  seccomp_load(ctx);

  char * filename = "/bin/sh";
  char * argv[] = { "/bin/sh", NULL };
  char * envp[] = { NULL }; 
  syscall(59, filename, argv, envp);

  return 0;
}

```

这个方法还是挺简洁的，想禁掉哪个就可以禁掉哪个系统调用。
需要先安装
`sudo apt install libseccomp-dev libseccomp2 seccomp`
然后执行`gcc -o libseccomp libseccomp.c -lseccomp`

执行结果如下：

```
this is the beginning.
Bad system call
```
